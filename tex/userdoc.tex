
% Maybe some stuff about template metaprogramming in this chapter?

\chapter{User documentation}

\section{Target audience}

This document expects the reader to have a basic understanding of template
metaprogramming in C++.

%TODO

\section{Main concepts}

Mihalicza relates concepts in traditional run time programs and C++ template
metaprograms\cite{mihalicza-phd}:

\begin{center}
    \begin{tabular}{| c | c |}
        \hline
            Run time execution & C++ TMP execution \\ \hline \hline
            function call & template instantiation \\ \hline
            call stack & instantiation stack \\ \hline
            function parameter & template parameter \\ \hline
            return value & the referenced nested type \\ \hline
            function body & template definition \\
        \hline
    \end{tabular}
\end{center}

He also compares debug operations between run time and metaprograms:

\begin{center}
    \begin{tabular}{| c | c |}
        \hline
            Run time debug operation & C++ TMP debug operation \\ \hline \hline
            step in/over/out functon call & step in/over/out instantiation \\ \hline
            continue execution & continue compilation \\
        \hline
    \end{tabular}
\end{center}


%TODO

\section{Installation}

Metashell supports the following platforms:
\begin{itemize}
    \item Linux
    \item FreeBSD
    \item OpenBSD
    \item OS X
    \item Windows
\end{itemize}

In this section, installation instructions only for Linux is described.
Instructions for other platforms can be found in the README.md file shipped
with Metashell.

\subsection{Dependencies}

Install the dependent libraries and tools:

\begin{itemize}
    \item Termcap and Readline (version 6.3 or newer)
    \item CMake (2.18.12.2 or newer)
\end{itemize}

Acquire the source code from Github\cite{github} or any release site, and cd
into the source directory:

\begin{itemize}
    \item \texttt{cd metashell}
\end{itemize}

Build Clang with Templight\cite{templight}:

\begin{itemize}
    \item \texttt{cd templight}
    \item \texttt{mkdir build}
    \item \texttt{cd build}
    \item \texttt{cmake ../llvm -DLIBCLANG\_BUILD\_STATIC=ON}
    \item \texttt{make clang}
    \item \texttt{make libclang}
    \item \texttt{make libclang\_static}
    \item \texttt{cd ..}
\end{itemize}

\subsection{Building}

Now compile Metashell:

\begin{itemize}
    \item \texttt{mkdir bin}
    \item \texttt{cd bin}
    \item \texttt{cmake ..}
    \item \texttt{make}
\end{itemize}

The most important files that got compiled in this step (paths are relative to
the bin directory):

\begin{description}
    \item[\texttt{app/metashell}:] The program executable
    \item[\texttt{test/metashell\_test}:] Test executable
\end{description}

\subsection{Running tests}

To make sure everything will work correctly, running tests is advised:

\begin{itemize}
    \item \texttt{test/metashell\_test}
\end{itemize}

\section{Basic Usage}

Start metashell by running \texttt{app/metashell}.

\includegraphics[width=1\textwidth]{img/splash.eps}

%TODO maybe mention, that "> " is metashell?
After a splash screen is shown, an interactive shell with \texttt{"> "}
prompt string appears. This is the place, where the C++ code environment
required by the metaprogram can be entered.


%TODO moar usage

\section{Command reference}

In the following section, the following notations are used: command parameters
that are in square brackets are optional. Parameters that are between angle
brackets have to be replaced by the user with something.

\input{tex/command_reference}

